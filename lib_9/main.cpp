// Контейнеры STL: 
//stack, queue, priority_queue
//set, multiset, map, multimap
#include "H.h"
int _tmain(int argc, _TCHAR* argv[])
{
/*
Напишите шаблон функции для вывода значений stack, queue, priority_queue
обратите внимание на то, что контейнеры предоставляют РАЗНЫЕ методы для 
получения значений
*/

////////////////////////////////////////////////////////////////////////////////////
//stack

/*
Создайте стек таким образом, чтобы
а) элементы стека стали копиями элементов вектора
б) при выводе значений как вектора, так и стека порядок значений был одинаковым 
*/

////////////////////////////////////////////////////////////////////////////////////
//queue

/*
Создайте очередь, которая содержит указатели на объекты типа Point,
при этом явно задайте базовый контейнер.
Измените значения первого и последнего элементов посредством front() и back()
Подумайте, что требуется сделать при уничтожении такой очереди?
*/

////////////////////////////////////////////////////////////////////////////////////
/*
priority_queue
а) создайте очередь с приоритетами, которая будет хранить адреса строковых литералов - const char*
б) проинициализируйте очередь при создании с помощью вспомогательного массива с элементами const char*
в) проверьте "упорядоченность" значений (с помощью pop() ) - если они оказываются не упорядоченными, подумайте:
что сравнивается при вставке?	
*/
	
////////////////////////////////////////////////////////////////////////////////////
/*
set
a) создайте множество с элементами типа Point - подумайте, что необходимо определить
		в классе Point (и каким образом)
б) распечатайте значения элементов с помощью шаблона, реализованного в предыдущей лаб. работе
в) попробуйте изменить любое значение...
г) Создайте два множества, которые будут содержать одинаковые значения
		типа int, но занесенные в разном порядке
д) Вставьте в любое множество диапазон элементов из любого другого
	контейнера, например, элементов массива	(что происходит, если в массиве имеются дубли?)
*/

////////////////////////////////////////////////////////////////////////////////////
/*
map, multiset
а) создайте map, который хранит пары "фамилия, зарплата" - pair<const char*, int>,
при этом строки задаются строковыми литералами
б) заполните контейнер значениями посредством operator[] и insert()
в) распечатайте содержимое
г) замените один из КЛЮЧЕЙ на новый (была "Иванова", вышла замуж => стала "Петрова")	
*/
stop
/*
д) Сформируйте любым способом вектор с элементами типа string.
Создайте (и распечатайте для проверки) map<string, int>, который будет
содержать упорядоченные по алфавиту строки и
количество повторений каждой строки в векторе
*/
stop
/*
е) 
задан массив:
const char* words[] = {"Abba", "Alfa", "Beta", "Beauty" ,...};
создайте map, в котором каждой букве будет соответствовать совокупность 
лексиграфически упорядоченных слов, начинающихся с этой буквы.
Подсказка: не стоит хранить дубли одной и той же строки
	
//'A' -  "Abba" "Alfa"
//'B' -  "Beauty" "Beta"  ...
//...
*/
stop
/*
ж)
создайте структуру данных, которая будет хранить информацию о студенческих группах.
Для каждой группы должны хранится фамилии студентов (по алфавиту). При этом 
фамилии могут дублироваться
Сами группы тоже должны быть упорядочены по номеру		
номера 
*/

////////////////////////////////////////////////////////////////////////////////////
/*
multimap
а) создайте "англо-русский" словарь, где одному и тому же ключу будут соответствовать
несколько русских значений - pair<string,string>, например: strange: чужой, странный...
б) Заполните словарь парами с помощью метода insert или проинициализируйте с помощью 
вспомогательного массива пара (пары можно конструировать или создавать с помощью шаблона make_pair)
в) Выведите все содержимое словаря на экран
г) Выведите на экран только варианты "переводов" для заданного ключа. Подсказка: для нахождения диапазона
итераторов можно использовать методы lower_bound() и upper_bound()
*/
stop
	return 0;
}
